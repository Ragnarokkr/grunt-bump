### Usage Examples

#### Default Options
Running the task in this way, the `version` field of each source file will be automatically bumped to the next build release, using an indentation of 4 spaces.

```javascript
grunt.initConfig({
    <%= meta.altName.replace(/grunt\-/,'') %>: {
        options: {},
        files: [ 'package.json', 'manifest.json' ]
    }
})
```

It's also possible to manually *force* the bumping of a specific part. Just define the wanted part as parameter of the task on the command line. **The command line parameter has the priority over default and custom options.**

```shell
$ grunt <%= meta.altName.replace(/grunt\-/,'') %>:foo:major
```

This will run the task with `foo` as target and `major` as part to bump.

```shell
$ grunt <%= meta.altName.replace(/grunt\-/,'') %>::patch
```

This will run the task for all the specified targets using `patch` as part to bump.

#### Custom Options
Running the task in this way, the `version` field of each traget file will be bumped to the next minor release
using an indentation of 2 spaces, then the callback function is invoked after each file has been bumped. Inside the callback function it's possibile to see how the passed data parameter is used to retrieve useful informations to take
decisions on what to do. (In this example, we presume a `pkg` and `manifest` which are updated in their `version` field, according to the processed index.)

```javascript
grunt.initConfig({
    <%= meta.altName.replace(/grunt\-/,'') %>: {
        options: {
            part: 'minor',
            tabSize: 2,
            onBumped: function( data ) {
                if ( data.index === 0 ) {
                    grunt.config( 'pkg.version', data.version );
                } else {
                    grunt.config( 'manifest.version', data.version );
                }
            }
        },
        files: [ 'package.json', 'manifest.json' ]
    }
})
```